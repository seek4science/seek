<% environment.context_class.instance_eval { include Seek::Util.routes } %>

const ajaxCall = (url, method, params) => {
  const { data, cache, dataType } = params;
  if (!url || !method) throw new Error("Parameter(s) missing");
  return $j.ajax({
    method,
    url,
    data,
    dataType,
    cache: cache || false,
     headers: {
      "Content-Type": "application/json",
      Accept: "application/json"
    }
  });
};

function updateBreadcrumb(item) {
  $j(".bcrumb li a").removeClass("active");
  if (item) {
    const elements = {
      project: ["project", "folder"],
      investigation: ["investigation"],
      study: ["study", "source_table", "study_protocol", "study_samples_table", "study_experiment_overview"],
      assay: ["assay", "assay_protocol", "assay_samples_table", "assay_experiment_overview"]
    };
    item = Object.keys(elements).find((e) => elements[e].includes(item.toLowerCase()));
    let index = ["project", "investigation", "study", "assay"].indexOf(item);
    $j(`.bcrumb li:nth-child(${index + 1}) a`).addClass("active");
  }
}

let timer;
function debounce(func, timeout = 300) {
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, timeout);
  };
}

const batchSampleDeleteStruct = (ex_id, id) => ({
  id,
  ex_id
});

const batchSampleUpdateStruct = (ex_id, attribute_map, id) => ({
  id,
  ex_id,
  data: {
    type: "samples",
    attributes: {
      attribute_map
    }
  }
});

const getAccessType = (code) => {
  switch (code) {
    case 0:
      return "no_access";
    case 1:
      return "view";
    case 2:
      return "download";
    case 3:
      return "edit";
    case 4:
      return "manage";
  }
};

const getAccess = (projectDefaultPolicy) => getAccessType(projectDefaultPolicy?.access_type || 0);

const getPermission = (projectDefaultPolicy, pid) => {
  const t = projectDefaultPolicy?.permissions;
  const accessType =
    t && t.find((x) => x.contributor_type == "Project" && x.contributor_id == pid)?.access_type;
  return getAccessType(accessType || 0);
};

const batchSampleCreateStruct = (
  ex_id,
  attribute_map,
  sample_type_id,
  pid,
  projectDefaultPolicy,
  assay_id = null
) => ({
  ex_id,
  data: {
    type: "samples",
    attributes: {
      policy: {
        access: getAccess(projectDefaultPolicy),
        permissions: [
          {
            resource: { type: "Project", id: pid },
            access: getPermission(projectDefaultPolicy, pid)
          }
        ]
      },
      attribute_map
    },
    tags: null,
    relationships: {
      projects: {
        data: [
          {
            id: pid,
            type: "projects"
          }
        ]
      },
      sample_type: {
        data: {
          id: sample_type_id,
          type: "sample_types"
        }
      },
      ...(assay_id && {
        assays: {
          data: [
            {
              id: assay_id,
              type: "assays"
            }
          ]
        }
      })
    }
  }
});

//** =============Autocomplete============== */
async function setAutoComplete(e, cvId) {
  $j(e).on("input", function () {
    debounce(fetchTerms, 500)($j(e), cvId);
  });
  if ($j(e).autocomplete() && !$j($j(e).autocomplete("widget")).is(":visible")) {
    fetchTerms($j(e), cvId);
  }
}

const setSource = (elem, data) => {
  elem.autocomplete({
    classes: {
      "ui-autocomplete": "highlight"
    },
    source: data.results.map(x => x.text),
    minLength: 0,
    mustMatch: true
  });
};

async function fetchTerms(elem, cvId) {
  if (!elem.find(".loader").length) elem.append("<span class='loader'></span>");
	const url = '<%= typeahead_sample_controlled_vocabs_path %>' + `?q=${elem.text()}&scv_id=${cvId}`
  const res = await ajaxCall(url, "GET", { dataType: "json" });
	setSource(elem, res);
	elem.focus().autocomplete("search");
	elem.find(".loader").remove();
}
//** =============End Autocomplete============== */

async function batchCreateSample(sampleTypes, projectDefaultPolicy) {
  try {
    let data = [];
    sampleTypes.forEach((s) => {
      s.samples.forEach((sa, k) => {
        data.push(
          batchSampleCreateStruct(sa.exId, sa.data, s.sampleTypeId, s.pid, projectDefaultPolicy, s.assayId)
        );
      });
    });

    if (data.length == 0) {
      return;
    }
    return ajaxCall("<%= batch_create_samples_path %>", "POST", { data: JSON.stringify({ data }) });
  } catch (e) {
    console.log(e);
  }
}

async function batchDeleteSample(sampleTypes) {
  try {
    let data = [];
    sampleTypes.forEach((s) => {
      s.samples.forEach((sa, k) => {
        data.push(batchSampleDeleteStruct(sa.exId, sa.id));
      });
    });

    if (data.length == 0) {
      return;
    }
    return ajaxCall("<%= batch_delete_samples_path %>", "DELETE", { data: JSON.stringify({ data }) });
  } catch (e) {
    console.log(e);
  }
}

// Helper function
// Returns `true` if `row` has '#HIDDEN' as a value for one of the fields
function rowHasHiddenFields(row) {
    let hasHiddenFields = false;
    for (const attr in row) {
      const val = row[attr];
      if (Array.isArray(val)) {
        hasHiddenFields = hasHiddenFields || val.some(input => input.title === '#HIDDEN'); // Sample has hidden Registered Samples in list
      } else if (typeof val === 'object' && val !== null && 'title' in val) {
        hasHiddenFields = hasHiddenFields || (val.title === '#HIDDEN'); // Sample has hidden Registered Sample
      } else {
        hasHiddenFields = hasHiddenFields || (val === '#HIDDEN'); // Sample is completely hidden
      }
    }
  return hasHiddenFields;
}

// This function is called when 'excel-export' btn is clicked.
// Posts the content of the dynamic table to the single_pages_controller,
// which generates an excel workbook based on a template.
async function exportToExcel(tableName, studyId, assayId, sampleTypeId, projectId) {
  const table = $j(`table[id=${tableName}]`);

  // Checks whether the dynamic table has errors
  // The excel export will be aborted as long as the dynamic table has errors
  hasErrorcells = table.find('select.select2__error').size() > 0
  if (hasErrorcells) {
    alert('It appears this sample table has some errors. Please correct the errors in the current sample table and try downloading again.');
    return;
  }

  // Fetch headers and rows
  const headers = table.DataTable().columns().titles().toArray();
  const rows = table.DataTable().data().toArray();

  // Check whether the rows have the same number of values as the header
  const rowValsMatchHeaders = rows.every((row, index) => {
    if(row.length !== headers.length) {
      console.error(`The number of values in row '${index}' is different from the header length.`);
      return false;
    }
    return true;
  });

  if (!rowValsMatchHeaders) {
    alert("Invalid request! See console for more information.");
    return false;
  }

  // Get the ID field (instance name + " id")
  const idFieldName = "<%= Seek::Config.instance_name %> id";

  // Construct the list of objects
  const sampleIds = rows.map((row) => {
    return headers.reduce((obj, header, i) => {
      // The first cell is the checkbox and  its header is empty string
      if (header === '' && i === 0){
        obj['selected'] = row[i];
      } else {
        obj[header] = row[i];
      }
      return obj;
      },
      {});
  })
  // Only include selected rows
    .filter(row => row.selected)
  // Exclude rows with hidden values
    .filter(row => !rowHasHiddenFields(row))
  // Finally only use the sample IDs
    .map(row => row[idFieldName]);

  // Use ajax for POST request with table data in the body
  // If succes => Redirect to download path for retrieving excel file
  $j.ajax({
    type: 'POST',
    headers: {
      'Accept': 'application/json'
    },
    url: '<%= export_to_excel_single_pages_path() %>',
    data: { sample_ids: JSON.stringify(sampleIds),
      sample_type_id: JSON.stringify(sampleTypeId),
      study_id: JSON.stringify(studyId),
      assay_id: JSON.stringify(assayId),
    }
  })
  .done( function(response){
    window.location.href = `<%= download_samples_excel_single_pages_path() %>?uuid=${response.uuid}`;
  })
  .fail( function(response){
    alert(`Failed to export through excel!\nStatus: ${response.status} - ${JSON.stringify(response.error().statusText)}\nError: ${response.responseText}`);
  })
  .always( function(response){
    setTimeout(() => {
      const itemType = assayId == null ? 'study' : 'assay';
      const itemId = assayId == null ? studyId : assayId;
      if (projectId && itemType && itemId) {
        window.location.href = `/single_pages/${projectId}?item_type=${itemType}&item_id=${itemId}`;
      } else {
        // If one of the variables is missing, just reload the current page.
        location.reload();
      }
    }, 2000);
  });
}

async function batchUpdateSample(sampleTypes) {
  try {
    let data = [];
    sampleTypes.forEach((s) => {
      s.samples.forEach((sa, k) => {
        data.push(batchSampleUpdateStruct(sa.exId, sa.data, sa.id));
      });
    });

    if (data.length == 0) {
      return;
    }
    return ajaxCall("<%= batch_update_samples_path %>", "PUT", { data: JSON.stringify({ data }) });
  } catch (e) {
    console.log(e);
  }
}

async function handleUploadSubmit(formData){
  $j.ajax({
    type: 'POST',
    url: "<%= upload_samples_single_pages_path %>",
    data: formData,
    dataType: 'html',
    processData: false,
    contentType: false,
    enctype: 'multipart/form-data',
    success: function(response){
      $j('#upload-excel-modal').modal({backdrop: 'static', keyboard: false}, 'show').focus();
      $j('#upload-excel').html(response);
    },
    error: function(err){
        alert(`Failed to upload file!\nStatus: ${err.status} - ${err.statusText}\nError: ${err.responseText}`);
      location.reload(); // Page needs reloading for the notice message to appear
    }
  });
}

function isMobile() {
	/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
}
