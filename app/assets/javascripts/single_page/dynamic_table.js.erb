<% environment.context_class.instance_eval { include Seek::Util.routes } %>

const rowStatus = { new: "new", delete: "delete", update: "update", empty: "empty", noAction: "" };
const dtErrClass = "row-error",
  dtSuccessClass = "row-success",
  dtDeletedClass = "disabled",
  dtRowDelete = "row-delete";
const defaultCols = [
  {
    width: "10px",
    className: "text-center",
    mRender: function (data, type, full) {
      return "<td><input class='row-select' type='checkbox' onClick='handleCheck($j(this))'/></td>";
    }
  }
];

const objectInput =
  "<td><input data-role='seek-objectsinput' data-tags-limit='3' " +
  "data-existing-objects='%EXISTING%' data-typeahead='true' " +
  "data-typeahead-query-url=%URL% /></td>";
const typeaheadUrl = '<%= typeahead_samples_path %>' + "?query=%QUERY&linked_sample_type_id=%LINKED%";

const handleCheck = (e) => (e.parents("table").DataTable().row(e.closest("tr")).data()[0] = e.is(":checked"));

(function ($j) {
  $j.dynamicTable = function (table) {
    this.table = table instanceof $j ? table : $j(table);
  };
  $j.dynamicTable.prototype = {
    init: function (rows, columns, options = {}) {
      columns
        .filter((c) => c.multi_link)
        .forEach((c) => {
          c["mRender"] = function (data, type, full) {
            const existingObjectsJSON = (data && Array.isArray(data) ? data : [data]).map(
              ({ id, title }) => ({
                id: id,
                name: title
              })
            );
            const existingObjects = JSON.stringify(existingObjectsJSON);
            const url = typeaheadUrl.replace("%LINKED%", c.linked_sample_type);
            if (options.readonly) {
              return existingObjectsJSON.map((e) => `<span class="badge">${e.name}</span>`).join(" ");
            } else {
              return objectInput.replace("%EXISTING%", existingObjects).replace("%URL%", url);
            }
          };
          c["createdCell"] = function (td, cellData, rowData, row, col) {
            setTagsInput($j(td));
          };
        });
      columns.unshift(...defaultCols);
      const columnDefs = [
        { orderable: false, targets: options.readonly ? [0] : [0, 1, 2] },
        {
          targets: options.readonly ? [] : [1, 2],
          visible: false,
          searchable: false
        }
      ];
      const editor = this.editor;
      this.table = this.table.DataTable({
        columnDefs,
        columns,
        scrollX: "100%",
        errMode: "throw",
        order: [[options.readonly ? 1 : 3, "asc"]],
        pageLength: 25,
        dom:
          "<'row'<'col-sm-3'l><'col-sm-5'B><'col-sm-4'f>>" +
          "<'row'<'col-sm-12'tr>>" +
          "<'row'<'col-sm-5'i><'col-sm-7'p>>",
        buttons: [
            {
                extend: 'copyHtml5',
                exportOptions: {
                    columns: options.readonly ? [':visible:not(.text-center)'] :[2, ':visible:not(.text-center)']
                }
            },
            {
                extend: 'csvHtml5',
                exportOptions: {
										// exclude checkbox column
                    columns: options.readonly ? [':visible:not(.text-center)'] :[2, ':visible:not(.text-center)']
                }
            },
            'colvis'
        ],
        ajax: options.ajax
      });
      this.table.rows.add(rows.map((r) => [null, ...r])).draw();
      if (!options.readonly) {
        const table = this.table;
        const context = this;
        this.table.on("click", "tbody td:not(:has(input))", function () {
          editor($j(this), table, context);
        });
      }
      if (options.assayId) this.assayId = options.assayId;
      this.initHeader(columns);
      this.options = options;
    },
    initHeader: function (columns) {
      const requiredCols = columns.map((c, i) => c.required && i).filter((c) => c);
      this.table
        .columns()
        .header()
        .each((x, i) => {
          if (i && requiredCols.includes(i)) {
            $j(x).append("<span class='required-attribute'>*</span>");
          }
          $j(x)
            .attr("title", columns[i].description)
            .attr("data-toggle", "tooltip")
            .attr("data-placement", "top")
            .attr("data-container", "body");
        });
      $j('[data-toggle="tooltip"]').tooltip();
    },
    pasteFromClipboard: function () {
      navigator.clipboard.readText().then((text) => {
        const colsCount = this.table.columns().data().length;
        const splitter = text.includes("\r\n") ? "\r\n" : "\n";
        const delimeter = "\t";
				const _defaultCols = defaultCols.map((c) => c.defaultValue || "")

				const cols = this.table.settings()[0].aoColumns;
				const sampleLinks = getSampleLinking(cols)
				const sampleLinkIndexes = sampleLinks.map(x => x.idx).sort((a, b) => b - a)
				const sampleLinksTitles = sampleLinks.map(x => x.title)

        const rows = text.split(splitter).map((r) => {
					// Preserve row status and id
          let splitted = [rowStatus.new, ""].concat(r.split(delimeter));
          const missingColsCount = colsCount - defaultCols.length - splitted.length;
          splitted = _defaultCols.concat(splitted);

					// Preserve empty placeholder for columns of type of 'Registered Sample (multiple)'
					sampleLinkIndexes.forEach((x) => (splitted.splice(x, 0, [])));

          return missingColsCount < 0
            ? splitted.slice(0, colsCount)
            : splitted.concat(Array(missingColsCount).fill(""));
        });
        this.table.rows.add(rows).draw();

				if (sampleLinksTitles.length)
					alert("No value is pasted for the following column(s): \n" + 
						sampleLinksTitles.map(x=>`"${x}"`).join(', ') + "\nYou need to manually input them.");
      });
    },
    newRow: function () {
      const colsCount = this.table.columns().data().length;
      const arr = defaultCols
        .map((c) => c.defaultValue || "")
        .concat(Array(colsCount - defaultCols.length).fill(""));
      const cols = this.table.settings()[0].aoColumns;
      const indexes = getStatusIndexes(cols);
      const sampleLinkIndexes = getSampleLinking(cols).map( x => x.idx)
      indexes.forEach((x) => (arr[x] = rowStatus.new));
      sampleLinkIndexes.forEach((x) => (arr[x] = []));
      this.table.row.add(arr).draw();
			updateContainerHeight();
    },
    setAsDeleted: function () {
      const indexes = getStatusIndexes(this.table.settings()[0].aoColumns);
      const deleteRowInx = [];
      const table = this.table;
      table.rows(function (idx, data, node) {
        let hasId = false;
        // If selected
        if (data[0]) {
          indexes.forEach((x) => {
            // empty status is a placeholder for missing samples
            // Check if the sample has an ID (data[x+1]) (it's an existing sample)
            if (data[x + 1]) {
              data[x] = rowStatus.delete;
              $j(node).find("td").addClass(dtRowDelete);
            } else hasId = true;
          });
          // There is only one status column in regular table
          if (hasId) deleteRowInx.push(idx);
        }
      });
      if (deleteRowInx.length) table.rows(deleteRowInx).remove().draw();
    },
    save: async function () {
      const { enableLoading, disableLoading } = this.options;
      if (enableLoading) enableLoading();
      this.resetClasses();
      //=======================DELETE==================================
      const deletedSamples = this.getSamples(rowStatus.delete);
      //* Delete action is applied to all samples in a row
      let res = await batchDeleteSample(deletedSamples);
      if (res) handleResponse(this.table, deletedSamples)(res);
      //=======================UPDATE==================================
      const updatedSamples = this.getSamples(rowStatus.update);
      res = await batchUpdateSample(updatedSamples);
      if (res) handleResponse(this.table, updatedSamples)(res);
      //=======================CREATE==================================
      const sampleTypeIds = this.getSampleTypes();
      for (const s of sampleTypeIds) {
        const newSamples = this.getSamples(rowStatus.new, s);
        res = await batchCreateSample(newSamples, projectDefaultPolicy);
        if (res) {
          handleResponse(this.table, newSamples)(res);
        }
      }
      if (this.options.callback && typeof this.options.callback === "function") {
        this.options.callback();
      }
      if (disableLoading) disableLoading();
    },
    headers: function () {
      return this.table
        .columns()
        .header()
        .toArray()
        .map((x) => x.innerText)
        .slice(defaultCols.length);
    },
    getSampleTypes: function () {
      return this.table
        .settings()[0]
        .aoColumns.map((c) => c.name)
        .filter((value, index, self) => value && self.indexOf(value) === index);
    },
    getSamples: function (status, sampleTypeId = null) {
      const rowsIdx = this.table.rows().indexes().toArray();
      const sampleTypeIds = sampleTypeId ? [sampleTypeId] : this.getSampleTypes();
      return sampleTypeIds.map((s) => {
        const columnNames = this.table
          .settings()[0]
          .aoColumns.filter((c) => c.name === s)
          .map((c) => c.title);
        return {
          pid: pid.toString(),
          sampleTypeId: s,
          assayId: this.assayId,
          // Returning those samples that apply the 'status'
          samples: rowsIdx.reduce((filtered, i) => {
            const item = this.table.cells(i, `${s}:name`).data().toArray();
            if (item[0] == status)
              filtered.push({
                id: item[1],
                exId: `${i}-${s}`,
                data: item.reduce((obj, curr, j) => ({ ...obj, [columnNames[j]]: checkSampleLink(curr) }), {})
              });
            return filtered;
          }, [])
        };
      });
    },
    log: function () {
      console.log(this.table.rows().data());
    },
    getCvId: function (colIndex) {
      return this.table.settings()[0].aoColumns[colIndex].cv_id;
    },
    editor: function (elem, table, context) {
      elem
        .attr("contenteditable", true)
        .focus()
        .unbind()
        .blur(function () {
          table.cell(elem).data(elem.text());
          elem.attr("contenteditable", false);
          table.columns.adjust();
          handleCellUpdate(table, elem);
        });

      const colIndex = table.cell(elem).index().column;
      const cvId = context.getCvId(colIndex);
      if (cvId) setAutoComplete(elem, cvId);
    },
    resetClasses: function () {
      $j(`#${this.table.tables().nodes().to$().attr("id")} td`).removeClass(dtErrClass);
    },
    toggleSampleType: function (sampleTypeId, visible) {
      this.table.columns(`${sampleTypeId}:name`).visible(visible);
    }
  };
})(jQuery);

function checkSampleLink(value) {
  if (Array.isArray(value)) {
    return value.map((x) => x.id).join(",");
  } else return value;
}

function sampleStatus(table, rowId, sampleTypeId, value = "notSet") {
  const sampleStatusIndex = table
    .settings()[0]
    .aoColumns.findIndex((x) => x?.status && x.name == sampleTypeId);
  if (value !== "notSet") table.row(rowId).data()[sampleStatusIndex] = value;
  else return table.row(rowId).data()[sampleStatusIndex];
}

function getStatusIndexes(arr) {
  return arr.filter((x) => x?.status).map((x) => x.idx);
}

function getSampleLinking(arr) {
  return arr.filter((x) => x.linked_sample_type).map(({ idx, title }) => ({ idx, title }));
}

function setTagsInput(item) {
  // There's a new input after the table is rendered
  const newInput = item.find("input").first();
  loadObjectInputs({ item: newInput });
  newInput.on("itemAdded itemRemoved", function (event) {
    const items = $j(this).tagsinput("items");
    const values = items.map(({ id, name }) => ({
      id,
      title: name
    }));
    const table = $j(this).parents("table").DataTable();
    const elem = $j(this).parent();
    const td = $j(this).closest("td");
    table.cell(elem).data(values);
    handleCellUpdate(table, elem);
    setTagsInput($j(td));
    table.columns.adjust();
  });
}

function handleCellUpdate(table, cell) {
  const { row, column } = table.cell(cell).index();
  const colName = table.settings()[0].aoColumns[column].name;
  // sampleType status col index
  const sampleStatusIndex = table.settings()[0].aoColumns.findIndex((x) => x?.status && x.name == colName);
  // If it is a new sample, then it has to be created
  const status = table.row(row).data()[sampleStatusIndex];
  if (status == rowStatus.empty) {
    table.row(row).data()[sampleStatusIndex] = rowStatus.new;
  } else if (status == "") {
    table.row(row).data()[sampleStatusIndex] = rowStatus.update;
  }
}

function handleResponse(table, sampleTypes) {
  return function (res) {
    if (res.status == "ok") handleSuccess(table, sampleTypes, res);
    else handleFailure(table, res);
  };
}

const handleFailure = (table, res) => {
  const errors = new Set();
  errors.add(
    "The operation can not be performed for one or some samples. The red cells indicate unacceptable values."
  );
  res.errors.forEach((error) => {
    const [rowId, sampleTypeId] = error.ex_id.split("-");
    const errorColNames = Object.keys(error.error);
    if (errorColNames.includes("base")) errors.add(error.error["base"]);
    table.cells(rowId, `${sampleTypeId}:name`).every(function () {
      const idx = this.index().column;
      const colTitle = $j(table.column(idx).header()).text().replace("*", "");
      if (errorColNames.includes(colTitle)) {
        $j(this.node()).addClass(dtErrClass);
        $j(this.node()).attr("title", error.error[colTitle]);
      } else if (error.error == "Can not be deleted.") {
        $j(this.node()).addClass(dtErrClass);
      }
    });
  });
  alert([...errors].reverse().join("\n"));
};

const handleSuccess = (table, sampleTypes, res) => {
  sampleTypes.forEach((s) => {
    s.samples.forEach((sa, k) => {
      const [rowId, sampleTypeId] = sa.exId.split("-");
      table.cells(rowId, `${sampleTypeId}:name`).every(function (rowIdx, columnIdx) {
        // Here id column index is 2 (being read from table.columns() that includes the select column)
        if (res.results && columnIdx == 2) {
          // update created samples' id in the table
          const id = res.results.find((r) => r.ex_id == sa.exId).id;
          this.data(id);
        }
        sampleStatus(table, rowId, sampleTypeId, rowStatus.noAction);
        $j(this.node()).addClass(dtSuccessClass);
      });
    });
  });
};
